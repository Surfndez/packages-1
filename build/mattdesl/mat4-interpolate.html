<h1 id="mat4-interpolate"><a target="_blank" href="http://github.com/mattdesl/mat4-interpolate">mat4-interpolate</a></h1>
<p><a href="http://github.com/badges/stability-badges"></a></p>
<p>Interpolates between two 4x4 matrices, using algorithms from W3C Spec to produce consistent results with CSS animations. Like <a href="https://www.npmjs.org/package/mat4-interpolator">mat4-interpolator</a> but does the decomposition in place. </p>
<p>Translation, scale, skew and perspective are interpolated linearly, and rotation is interpolated with spherical interpolation.</p>
<pre><code class="lang-js"><span class="kd">var</span> <span class="nx">mat4</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;gl-mat4&apos;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">end</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nx">fromRotationTranslation</span><span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">])</span>
<span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">()</span>

<span class="c1">//the matrix interpolator</span>
<span class="kd">var</span> <span class="nx">interpolate</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;mat4-interpolate&apos;</span><span class="p">)</span>


<span class="c1">//.. in your render loop</span>
<span class="kd">function</span> <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//interpolate based on alpha, storing results in &apos;out&apos; matrix</span>
    <span class="kd">var</span> <span class="nx">vlid</span> <span class="o">=</span> <span class="nx">interpolate</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">valid</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//could not interpolate, you need to animate yourself somehow   </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id="usage">Usage</h2>
<p><a href="https://nodei.co/npm/mat4-interpolate/"></a></p>
<h4 id="-valid-interpolate-out-start-end-alpha-"><code>valid = interpolate(out, start, end, alpha)</code></h4>
<p>Interpolates between <code>start</code> and <code>end</code> matrices (16 floats in an array) and stores the result in <code>out</code>, using <code>alpha</code> for interpolation. This will decompose the two matrices into components, lerp/slerp, and then recompose.</p>
<p>Returns <code>true</code> is the interpolation succeeded, or <code>false</code> if either matrix is non-invertible (i.e. scale or perspective W of zero). W3C suggests falling back to discrete animations in this case.</p>
<h2 id="license">License</h2>
<p>MIT, see <a href="http://github.com/mattdesl/mat4-interpolate/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
