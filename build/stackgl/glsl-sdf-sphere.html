<h1 id="glsl-sdf-sphere"><a target="_blank" href="http://github.com/stackgl/glsl-sdf-sphere">glsl-sdf-sphere</a></h1>
<p><a href="http://github.com/badges/stability-badges"></a></p>
<p>GLSL SDF function for generating a sphere. Determines the distance between a
point and the surface of a sphere at the origin.</p>
<p><strong><a href="http://stack.gl/glsl-sdf-sphere/">view demo</a></strong></p>
<iframe scrolling="no" seamless="seamless" src="http://stack.gl/glsl-sdf-sphere/"></iframe><h2 id="usage">Usage</h2>
<p><a href="https://nodei.co/npm/glsl-sdf-sphere/"></a></p>
<h3 id="-float-sphere-vec3-position-float-radius-"><code>float sphere(vec3 position, float radius)</code></h3>
<p>Returns the signed distanced between <code>position</code> and a sphere at the origin
with a given <code>radius</code>. For example, to draw a sphere in a raytracing shader:</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: sphere = require(&apos;glsl-sdf-sphere&apos;)</span>

<span class="k">vec2</span> <span class="n">doModel</span><span class="p">(</span><span class="k">vec3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">float</span> <span class="n">id</span>     <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">dist</span>   <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>

  <span class="k">return</span> <span class="k">vec2</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Note that you can move the sphere around in this case by offsetting the
<code>position</code> vector, for example:</p>
<pre><code class="lang-glsl"><span class="k">uniform</span> <span class="k">float</span> <span class="n">iGlobalTime</span><span class="p">;</span>

<span class="cp">#pragma glslify: sphere = require(&apos;glsl-sdf-sphere&apos;)</span>

<span class="k">vec2</span> <span class="n">doModel</span><span class="p">(</span><span class="k">vec3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">vec3</span> <span class="n">offset</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">iGlobalTime</span><span class="p">),</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>

  <span class="k">float</span> <span class="n">id</span>     <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">dist</span>   <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>

  <span class="k">return</span> <span class="k">vec2</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h2 id="contributing">Contributing</h2>
<p>See <a href="https://github.com/stackgl/contributing">stackgl/contributing</a> for details.</p>
<h2 id="license">License</h2>
<p>MIT. See <a href="http://github.com/stackgl/glsl-sdf-sphere/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
