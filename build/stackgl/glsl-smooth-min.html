<h1 id="glsl-smooth-min">glsl-smooth-min</h1>
<p><a href="http://github.com/badges/stability-badges"></a></p>
<p>Smooth minimum functions for GLSL, sourced from
<a href="http://www.iquilezles.org/www/articles/smin/smin.htm">I&#xF1;igo Qu&#xED;lez&apos;s article</a>.</p>
<p>Particularly useful when doing Shadertoy-style raymarching with distance
fields: you can smoothly blend between two volumes, instead of doing a
hard union with <code>min(a, b)</code>.</p>
<p><strong><a href="http://stack.gl/glsl-smooth-min">Check it out in action</a></strong></p>
<p><iframe scrolling="no" seamless="seamless" src="http://stack.gl/glsl-smooth-min/"></iframe></p>
<h2 id="usage">Usage</h2>
<p><a href="https://nodei.co/npm/glsl-smooth-min/"></a></p>
<h3 id="-smin-float-a-float-b-float-k-"><code>smin(float a, float b, float k)</code></h3>
<p>Blends smoothly between <code>a</code> and <code>b</code>, with a smoothing amount
determined by the value of <code>k</code>. For example:</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: smin = require(glsl-smooth-min)</span>

<span class="k">float</span> <span class="n">doModel</span><span class="p">(</span><span class="k">vec3</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Take two sphere volumes</span>
  <span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.7</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.7</span><span class="p">;</span>

  <span class="c1">// And smooth them together</span>
  <span class="k">return</span> <span class="n">smin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>There are three variants of this function available, all with the
same function signature:</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: poly = require(glsl-smooth-min/poly)</span>
<span class="cp">#pragma glslify: pow = require(glsl-smooth-min/pow)</span>
<span class="cp">#pragma glslify: exp = require(glsl-smooth-min/exp)</span>

<span class="c1">// Exports `poly` by default</span>
<span class="cp">#pragma glslify: poly = require(glsl-smooth-min)</span>
</code></pre>
<p>Each of these variants differ somewhat in their results,
and some are more appropriate in specific situations:</p>
<blockquote>
<p>These three functions produce smooth results, with different qualities. The three accept a paramter <em>k</em> that controls the radious/distance of the smoothness. From these three, probably the polynomial is the fastest, and also the easiest to control, for <em>k</em> maps directly to a blending band size/distance. Unlike the other two, it probably suffers from second order discontinuities (derivatives), but visually is pleasing enough for most applications.</p>
</blockquote>
<h2 id="contributing">Contributing</h2>
<p>See <a href="https://github.com/stackgl/contributing">stackgl/contributing</a> for details.</p>
<h2 id="license">License</h2>
<p>MIT. See <a href="http://github.com/stackgl/glsl-smooth-min/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
