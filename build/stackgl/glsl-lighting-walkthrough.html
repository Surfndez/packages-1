<h2 id="glsl-lighting-walkthrough"><a target="_blank" href="http://github.com/stackgl/glsl-lighting-walkthrough">glsl-lighting-walkthrough</a></h2>
<p><iframe scrolling="no" seamless="seamless" src="http://stack.gl/glsl-lighting-walkthrough/"></iframe></p>
<p><a href="http://stack.gl/glsl-lighting-walkthrough/">(live demo)</a></p>
<p>This article provides an overview of the various steps involved in lighting a mesh with a custom GLSL shader. Some of the features of the demo:</p>
<ul>
<li>per-pixel lighting</li>
<li>flat &amp; smooth normals</li>
<li>gamma correction for working in linear space</li>
<li>normal &amp; specular maps for detail</li>
<li>attenuation for point light falloff</li>
<li>Oren-Nayar diffuse for rough surfaces</li>
<li>Phong reflectance model for specular highlights</li>
</ul>
<p>It is not intended as a full-blown beginner&apos;s guide, and assumes prior knowledge of WebGL and stackgl rendering. Although it is implemented with stackgl, the same concepts and shader code could be used in ThreeJS and other frameworks.</p>
<p>If you have questions, comments or improvements, please <a href="https://github.com/stackgl/glsl-lighting-walkthrough/issues">post a new issue</a>.</p>
<h2 id="contents">contents</h2>
<ul>
<li><a href="#running-from-source">running from source</a></li>
<li><a href="#code-overview">code overview</a></li>
<li><a href="#shaders">shaders</a></li>
<li><a href="#phong">phong</a><ul>
<li><a href="#standard-derivatives">standard derivatives</a></li>
<li><a href="#vertex-shader">vertex shader</a></li>
<li><a href="#flat-normals">flat normals</a></li>
<li><a href="#smooth-normals">smooth normals</a></li>
<li><a href="#gamma-correction">gamma correction</a></li>
<li><a href="#normal-mapping">normal mapping</a></li>
<li><a href="#light-attenuation">light attenuation</a></li>
<li><a href="#diffuse">diffuse</a></li>
<li><a href="#specular">specular</a></li>
<li><a href="#final-color">final color</a></li>
</ul>
</li>
</ul>
<h2 id="running-from-source">running from source</h2>
<p>To run from source:</p>
<pre><code class="lang-sh">git clone https://github.com/stackgl/glsl-lighting-walkthrough.git
<span class="nb">cd </span>glsl-lighting-walkthrough

npm install
npm run start
</code></pre>
<p>And then open <code>http://localhost:9966</code> to see the demo. Changes to the source will live-reload the browser for development.</p>
<p>To build:</p>
<pre><code class="lang-sh">npm run build
</code></pre>
<h2 id="code-overview">code overview</h2>
<p>The code is using Babelify for ES6 template strings, destructuring, and arrow functions. It is organized like so:</p>
<ul>
<li><a href="index.js">index.js</a> - loads images, then boots up the app</li>
<li><a href="lib/app.js">lib/app.js</a> - sets up a WebGL render loop and draws the scene</li>
<li><a href="lib/scene.js">lib/scene.js</a> - sets up textures, positions the light and draws meshes</li>
<li><a href="lib/create-sphere.js">lib/create-sphere.js</a> - create a 3D sphere for the light source</li>
<li><a href="lib/create-torus.js">lib/create-torus.js</a> - creates a 3D torus with a phong shader</li>
</ul>
<h2 id="shaders">shaders</h2>
<p><a href="https://github.com/stackgl/glslify">glslify</a> is used to modularize the shaders and pull some common functions from <a href="https://www.npmjs.com/">npm</a>.</p>
<p>We use a &quot;basic&quot; material for our light indicator, so that it appears at a constant color regardless of depth and lighting:</p>
<ul>
<li><a href="lib/shaders/basic.frag">shaders/basic.frag</a></li>
<li><a href="lib/shaders/basic.vert">shaders/basic.vert</a></li>
</ul>
<p>We use a &quot;phong&quot; material for our torus, which we will explore in more depth below.</p>
<ul>
<li><a href="lib/shaders/phong.frag">shaders/phong.frag</a></li>
<li><a href="lib/shaders/phong.vert">shaders/phong.vert</a></li>
</ul>
<p>There are many ways to skin a cat; this is just one approach to phong shading. </p>
<h2 id="phong">phong</h2>
<h3 id="standard-derivatives">standard derivatives</h3>
<p>Our phong shader uses standard derivatives, so we need to enable the extension before we create it. The JavaScript code looks like this:</p>
<pre><code class="lang-js"><span class="c1">//enable the extension</span>
<span class="kd">var</span> <span class="nx">ext</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getExtension</span><span class="p">(</span><span class="s1">&apos;OES_standard_derivatives&apos;</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">ext</span><span class="p">)</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&apos;derivatives not supported&apos;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">shader</span> <span class="o">=</span> <span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span> <span class="nx">vert</span><span class="p">,</span> <span class="nx">frag</span><span class="p">)</span>
<span class="p">...</span>
</code></pre>
<p>And, in our fragment shader we need to enable it explicitly:</p>
<pre><code class="lang-glsl"><span class="cp">#extension GL_OES_standard_derivatives : enable</span>
<span class="k">precision</span> <span class="k">highp</span> <span class="k">float</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>The extension is used in two places in our final shader:</p>
<ul>
<li><a href="https://www.npmjs.com/package/glsl-face-normal">glsl-face-normal</a> for flat shading (optional)</li>
<li><a href="https://www.npmjs.com/package/glsl-perturb-normal">glsl-perturb-normal</a> for normal-mapping</li>
</ul>
<h3 id="vertex-shader">vertex shader</h3>
<p><img src="http://i.imgur.com/J24k2iu.png" alt="white"></p>
<p>Our vertex shader needs to pass the texture coordinates and view space position to the fragment shader. </p>
<p>A basic vertex shader looks like this:</p>
<pre><code class="lang-glsl"><span class="k">attribute</span> <span class="k">vec4</span> <span class="n">position</span><span class="p">;</span>
<span class="k">attribute</span> <span class="k">vec2</span> <span class="n">uv</span><span class="p">;</span>

<span class="k">uniform</span> <span class="k">mat4</span> <span class="n">projection</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">mat4</span> <span class="n">view</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">mat4</span> <span class="n">model</span><span class="p">;</span>

<span class="k">varying</span> <span class="k">vec2</span> <span class="n">vUv</span><span class="p">;</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">vViewPosition</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//determine view space position</span>
  <span class="k">mat4</span> <span class="n">modelViewMatrix</span> <span class="o">=</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span><span class="p">;</span>
  <span class="k">vec4</span> <span class="n">viewModelPosition</span> <span class="o">=</span> <span class="n">modelViewMatrix</span> <span class="o">*</span> <span class="n">position</span><span class="p">;</span>

  <span class="c1">//pass varyings to fragment shader</span>
  <span class="n">vViewPosition</span> <span class="o">=</span> <span class="n">viewModelPosition</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
  <span class="n">vUv</span> <span class="o">=</span> <span class="n">uv</span><span class="p">;</span>

  <span class="c1">//determine final 3D position</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">viewModelPosition</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<h3 id="flat-normals">flat normals</h3>
<p><img src="http://i.imgur.com/YvuhBGk.png" alt="flat"></p>
<p>If you want flat shading, you don&apos;t need to submit normals as a vertex attribute. Instead, you can use <a href="https://www.npmjs.com/package/glsl-face-normal">glsl-face-normal</a> to estimate them in the fragment shader:</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: faceNormals = require(&apos;glsl-face-normal&apos;)</span>

<span class="k">varying</span> <span class="k">vec3</span> <span class="n">vViewPosition</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">faceNormals</span><span class="p">(</span><span class="n">vViewPosition</span><span class="p">);</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="smooth-normals">smooth normals</h3>
<p><img src="http://i.imgur.com/hnYlRG5.png" alt="smooth"></p>
<p>For smooth normals, we use the object space normals from <a href="https://www.npmjs.com/package/torus-mesh">torus-mesh</a> and pass them to the fragment shader to have them interpolated between vertices.</p>
<p>To transform the object normals into view space, we multiply them by a &quot;normal matrix&quot; - the inverse transpose of the model view matrix.</p>
<p>Since this doesn&apos;t change vertex to vertex, you can do it CPU-side and pass it as a uniform to the vertex shader. </p>
<p>Or, you can just simply compute the normal matrix in the vertex step. GLSL ES does not provide built-in <code>transpose()</code> or <code>inverse()</code>, so we need to require them from npm:</p>
<ul>
<li><a href="https://www.npmjs.com/package/glsl-inverse">glsl-inverse</a></li>
<li><a href="https://www.npmjs.com/package/glsl-transpose">glsl-transpose</a></li>
</ul>
<pre><code class="lang-glsl"><span class="c1">//object normals</span>
<span class="k">attribute</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">vNormal</span><span class="p">;</span>

<span class="cp">#pragma glslify: transpose = require(&apos;glsl-transpose&apos;)</span>
<span class="cp">#pragma glslify: inverse = require(&apos;glsl-inverse&apos;)</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// Rotate the object normals by a 3x3 normal matrix.</span>
  <span class="k">mat3</span> <span class="n">normalMatrix</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="k">mat3</span><span class="p">(</span><span class="n">modelViewMatrix</span><span class="p">)));</span>
  <span class="n">vNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="gamma-correction">gamma correction</h3>
<p>When dealing with PNG and JPG textures, it&apos;s important to remember that they most likely have gamma correction applied to them already, and so we need to account for it when doing any work in linear space.</p>
<p>We can use <code>pow(value, 2.2)</code> and <code>pow(value, 1.0 / 2.2)</code> to convert to and from the gamma-corrected space. Or, <a href="https://github.com/stackgl/glsl-gamma">glsl-gamma</a> can be used for convenience.</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: toLinear = require(&apos;glsl-gamma/in&apos;)</span>
<span class="cp">#pragma glslify: toGamma  = require(&apos;glsl-gamma/out&apos;)</span>

<span class="k">vec4</span> <span class="n">textureLinear</span><span class="p">(</span><span class="k">sampler2D</span> <span class="n">uTex</span><span class="p">,</span> <span class="k">vec2</span> <span class="n">uv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">toLinear</span><span class="p">(</span><span class="n">texture2D</span><span class="p">(</span><span class="n">uTex</span><span class="p">,</span> <span class="n">uv</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//sample sRGB and account for gamma</span>
  <span class="k">vec4</span> <span class="n">diffuseColor</span> <span class="o">=</span> <span class="n">textureLinear</span><span class="p">(</span><span class="n">texDiffuse</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>

  <span class="c1">//operate on RGB in linear space</span>
  <span class="p">...</span>

  <span class="c1">//output final color to sRGB space</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">toGamma</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>For details, see <a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html">GPU Gems - The Importance of Being Linear</a>.</p>
<h3 id="normal-mapping">normal mapping</h3>
<p><img src="http://i.imgur.com/cJce72J.png" alt="normalmap"></p>
<p>We can use normal maps to add detail to the shading without additional topology.</p>
<p>A normal map typically stores a unit vector <code>[X,Y,Z]</code> in an image&apos;s <code>[R,G,B]</code> channels, respectively. The 0-1 colors are expanded into the -1 to 1 range, representing the unit vector.</p>
<pre><code class="lang-glsl"><span class="c1">// ... fragment shader ...</span>

  <span class="c1">//sample texture and expand to -1 .. 1</span>
  <span class="k">vec3</span> <span class="n">normalMap</span> <span class="o">=</span> <span class="n">textureLinear</span><span class="p">(</span><span class="n">texNormal</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="c1">//some normal maps use an inverted green channel</span>
  <span class="n">normalMap</span><span class="p">.</span><span class="n">y</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>

  <span class="c1">//determine perturbed surface normal</span>
  <span class="k">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vViewPosition</span><span class="p">);</span> 
  <span class="k">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">perturb</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="o">-</span><span class="n">V</span><span class="p">,</span> <span class="n">vUv</span><span class="p">);</span>
</code></pre>
<h3 id="light-attenuation">light attenuation</h3>
<p><img src="http://i.imgur.com/qZUMbUd.png" alt="attenuation"></p>
<p>For lighting, we need to determine the vector from the view space surface position to the view space light position. Then we can account for attenuation (falloff based on the distance from light), diffuse, and specular. </p>
<p>The relevant bits of the fragment shader:</p>
<pre><code class="lang-glsl"><span class="k">uniform</span> <span class="k">mat4</span> <span class="n">view</span><span class="p">;</span>

<span class="cp">#pragma glslify: attenuation = require(&apos;./attenuation&apos;)</span>

<span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">//determine surface to light vector</span>
  <span class="k">vec4</span> <span class="n">lightPosition</span> <span class="o">=</span> <span class="n">view</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="k">vec3</span> <span class="n">lightVector</span> <span class="o">=</span> <span class="n">lightPosition</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">vViewPosition</span><span class="p">;</span>

  <span class="c1">//calculate attenuation</span>
  <span class="k">float</span> <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lightVector</span><span class="p">);</span>
  <span class="k">float</span> <span class="n">falloff</span> <span class="o">=</span> <span class="n">attenuation</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">light</span><span class="p">.</span><span class="n">falloff</span><span class="p">,</span> <span class="n">lightDistance</span><span class="p">);</span>

  <span class="c1">//light direction</span>
  <span class="k">vec3</span> <span class="n">L</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightVector</span><span class="p">);</span>

  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>Our chosen <a href="lib/shaders/madams-attenuation.glsl">attenuation function</a> is by Tom Madams, but there are many others that we could choose from.</p>
<pre><code class="lang-glsl"><span class="k">float</span> <span class="n">attenuation</span><span class="p">(</span><span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">float</span> <span class="n">f</span><span class="p">,</span> <span class="k">float</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">denom</span><span class="o">*</span><span class="n">denom</span><span class="p">);</span>
  <span class="k">float</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">attenuation</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="diffuse">diffuse</h3>
<p><img src="http://i.imgur.com/pfqQCN7.png" alt="diffuse"></p>
<p>With our light direction, surface normal, and view direction, we can start to work on diffuse lighting. The color is multiplied by falloff to create the effect of a distant light.</p>
<p>For rough surfaces, <a href="https://www.npmjs.com/package/glsl-diffuse-oren-nayar">glsl-diffuse-oren-nayar</a> looks a bit better than <a href="https://www.npmjs.com/package/glsl-diffuse-lambert">glsl-diffuse-lambert</a>. </p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: computeDiffuse = require(&apos;glsl-diffuse-oren-nayar&apos;)</span>

  <span class="p">...</span>

  <span class="c1">//diffuse term</span>
  <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">*</span> <span class="n">computeDiffuse</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">albedo</span><span class="p">)</span> <span class="o">*</span> <span class="n">falloff</span><span class="p">;</span>

  <span class="c1">//texture color</span>
  <span class="k">vec3</span> <span class="n">diffuseColor</span> <span class="o">=</span> <span class="n">textureLinear</span><span class="p">(</span><span class="n">texDiffuse</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</code></pre>
<p>These shading functions are known as <a href="http://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function">bidirectional reflectance distribution functions</a> (BRDF).</p>
<h3 id="specular">specular</h3>
<p><img src="http://i.imgur.com/lDimd4U.png" alt="specular"></p>
<p>Similarly, we can apply specular with one of the following BRDFs:</p>
<ul>
<li><a href="https://www.npmjs.com/package/glsl-specular-blinn-phong">glsl-specular-blinn-phong</a></li>
<li><a href="https://www.npmjs.com/package/glsl-specular-phong">glsl-specular-phong</a></li>
<li><a href="https://www.npmjs.com/package/glsl-specular-ward">glsl-specular-ward</a></li>
<li><a href="https://www.npmjs.com/package/glsl-specular-gaussian">glsl-specular-gaussian</a></li>
<li><a href="https://www.npmjs.com/package/glsl-specular-beckmann">glsl-specular-beckmann</a></li>
<li><a href="https://www.npmjs.com/package/glsl-specular-cook-torrance">glsl-specular-cook-torrance</a></li>
</ul>
<p>Which one you choose depends on the material and aesthetic you are working with. In our case, <code>glsl-specular-phong</code> looks pretty good.</p>
<p>The above screenshot is scaled by 100x for demonstration, using <code>specularScale</code> to drive the strength. The specular is also affected by the light attenuation.</p>
<pre><code class="lang-glsl"><span class="cp">#pragma glslify: computeSpecular = require(&apos;glsl-specular-phong&apos;)</span>

  <span class="p">...</span>

  <span class="k">float</span> <span class="n">specularStrength</span> <span class="o">=</span> <span class="n">textureLinear</span><span class="p">(</span><span class="n">texSpecular</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
  <span class="k">float</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">specularStrength</span> <span class="o">*</span> <span class="n">computeSpecular</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">shininess</span><span class="p">);</span>
  <span class="n">specular</span> <span class="o">*=</span> <span class="n">specularScale</span><span class="p">;</span>
  <span class="n">specular</span> <span class="o">*=</span> <span class="n">falloff</span><span class="p">;</span>
</code></pre>
<h3 id="final-color">final color</h3>
<p><img src="http://i.imgur.com/ZN5FmKz.png" alt="final"></p>
<p>We now calculate the final color in the following manner. </p>
<pre><code class="lang-glsl"><span class="p">...</span>
  <span class="c1">//compute final color</span>
  <span class="k">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">diffuseColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span><span class="p">)</span> <span class="o">+</span> <span class="n">specular</span><span class="p">;</span>
</code></pre>
<p>Our final color is going straight to the screen, so we should re-apply the gamma correction we removed earlier. If the color was going through a post-processing pipeline, we could continue operating in linear space until the final step. </p>
<pre><code class="lang-glsl"><span class="p">...</span>
  <span class="c1">//output color</span>
  <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">toGamma</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
  <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">a</span>   <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</code></pre>
<p>The <a href="http://stack.gl/glsl-lighting-walkthrough/">final result</a>. </p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="http://www.tomdalling.com/blog/category/modern-opengl/">Tom Dalling - Modern OpenGL Series</a></li>
<li><a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html">GPU Gems - The Importance of Being Linear</a></li>
<li><a href="http://www.thetenthplanet.de/archives/1180">Normal Mapping Without Precomputed Tangents</a></li>
</ul>
<h2 id="license">License</h2>
<p>MIT. See <a href="http://github.com/stackgl/glsl-lighting-walkthrough/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
