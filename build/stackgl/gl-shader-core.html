<h1 id="gl-shader-core">gl-shader-core</h1>
<p>The core of <a href="https://github.com/mikolalysenko/gl-shader">gl-shader</a>, without the parser.  It can be used to compile shaders without including the (relatively large) glsl-parser dependencies, or invoked directly by libraries which use a transform.</p>
<h2 id="install">Install</h2>
<pre><code>npm install gl-shader-core
</code></pre><h2 id="api">API</h2>
<h3 id="-var-shader-require-gl-shader-core-gl-vertexsource-fragmentsource-uniforms-attributes-"><code>var shader = require(&quot;gl-shader-core&quot;)(gl, vertexSource, fragmentSource, uniforms, attributes)</code></h3>
<p>Constructs a packaged gl-shader object with shims for all of the uniforms and attributes in the program.</p>
<ul>
<li><code>gl</code> is the webgl context in which the program will be created</li>
<li><code>vertexSource</code> is the source code for the vertex shader</li>
<li><code>fragmentSource</code> is the source code for the fragment shader</li>
<li><code>uniforms</code> is a list of all uniforms exported by the shader program</li>
<li><code>attributes</code> is a list of all attributes exported by the shader program</li>
</ul>
<p>The uniform and attributes variables have output which is consistent with <a href="https://npmjs.org/package/glsl-extract">glsl-extract</a>. </p>
<p><strong>Returns</strong> A compiled shader object.</p>
<p>You can specify a default <code>location</code> number for each attribute, otherwise WebGL will bind it automatically. </p>
<h2 id="methods">Methods</h2>
<h3 id="-shader-bind-"><code>shader.bind()</code></h3>
<p>Binds the shader for rendering</p>
<h3 id="-shader-dispose-"><code>shader.dispose()</code></h3>
<p>Deletes the shader program and associated resources.</p>
<h2 id="properties">Properties</h2>
<h3 id="-gl-"><code>gl</code></h3>
<p>The WebGL context associated to the shader</p>
<h3 id="-handle-"><code>handle</code></h3>
<p>A handle to the underlying WebGL program object</p>
<h3 id="-vertexshader-"><code>vertexShader</code></h3>
<p>A handle to the underlying WebGL fragment shader object</p>
<h3 id="-fragmentshader-"><code>fragmentShader</code></h3>
<p>A handle to the underlying WebGL vertex shader object</p>
<h2 id="uniforms">Uniforms</h2>
<p>The uniforms for the shader program are packaged up as properties in the <code>shader.uniforms</code> object.  For example, to update a scalar uniform you can just assign to it:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span> <span class="o">=</span> <span class="mf">1.0</span>
</code></pre>
<p>While you can update vector uniforms by writing an array to them:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</code></pre>
<p>Matrix uniforms must have their arrays flattened first:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">]</span>
</code></pre>
<p>You can also read the value of uniform too if the underlying shader is currently bound.  For example,</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span><span class="p">)</span>
</code></pre>
<p>Struct uniforms can also be accessed using the normal dot property syntax.  For example,</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">light</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<h2 id="attributes">Attributes</h2>
<p>The basic idea behind the attribute interface is similar to that for uniforms, however because attributes can be either a constant value or get values from a vertex array they have a slightly more complicated interface.  All of the attributes are stored in the <code>shader.attributes</code> property.</p>
<h3 id="-attrib-constant-"><code>attrib = constant</code></h3>
<p>For non-array attributes you can set the constant value to be broadcast across all vertices.  For example, to set the vertex color of a shader to a constant you could do:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<p>This internally uses <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttrib.xml"><code>gl.vertexAttribnf</code></a>. Setting the attribute will also call <code>gl.disableVertexAttribArray</code> on the attribute&apos;s location.</p>
<h3 id="-attrib-location-"><code>attrib.location</code></h3>
<p>This property accesses the location of the attribute.  You can assign/read from it to modify the location of the attribute.  For example, you can update the location by doing:</p>
<pre><code class="lang-javascript"><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<p>Or you can read the currently bound location back by just accessing it:</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span><span class="p">)</span>
</code></pre>
<p>Internally, these methods just call <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindAttribLocation.xml"><code>gl.bindAttribLocation</code></a> and access the stored location.</p>
<p><strong>WARNING</strong> Changing the attribute location requires recompiling the program.  Do not dynamically modify this variable in your render loop.</p>
<h3 id="-attrib-pointer-type-normalized-stride-offset-"><code>attrib.pointer([type, normalized, stride, offset])</code></h3>
<p>A shortcut for <code>gl.vertexAttribPointer</code>/<code>gl.enableVertexAttribArray</code>.  See the <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml">OpenGL man page for details on how this works</a>.  The main difference here is that the WebGL context, size and index are known and so these parameters are bound.</p>
<ul>
<li><code>type</code> is the type of the pointer (default <code>gl.FLOAT</code>)</li>
<li><code>normalized</code> specifies whether fixed-point data values should be normalized (<code>true</code>) or converted directly as fixed-point values (<code>false</code>) when they are accessed.  (Default <code>false</code>)</li>
<li><code>stride</code> the byte offset between consecutive generic vertex attributes.  (Default: <code>0</code>)</li>
<li><code>offset</code> offset of the first element of the array in bytes. (Default <code>0</code>)</li>
</ul>
<h2 id="reflection">Reflection</h2>
<p>Finally, the library supports some reflection capabilities.  The set of all uniforms and data types are stored in the &quot;type&quot; property of the shader object,</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">types</span><span class="p">)</span>
</code></pre>
<p>This reflects the uniform and attribute parameters that were passed to the shader constructor.</p>
<h2 id="credits">Credits</h2>
<p>(c) 2013 Mikola Lysenko. MIT License</p>
