<h1 id="gl-shader"><a target="_blank" href="http://github.com/stackgl/gl-shader">gl-shader</a></h1>
<p>A wrapper for WebGL shaders.  Part of <a href="http://stack.gl">stack.gl</a></p>
<iframe scrolling="no" seamless="seamless" src="http://stack.gl/gl-shader/"></iframe><h1 id="example">Example</h1>
<p>Try it out now in your browser:  <a href="http://stackgl.github.io/gl-shader/">http://stackgl.github.io/gl-shader/</a></p>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">shell</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;gl-now&apos;</span><span class="p">)()</span>
<span class="kd">var</span> <span class="nx">createShader</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;gl-shader&apos;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">shader</span><span class="p">,</span> <span class="nx">buffer</span>

<span class="nx">shell</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&apos;gl-init&apos;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">gl</span>

  <span class="c1">//Create shader</span>
  <span class="nx">shader</span> <span class="o">=</span> <span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span>
    <span class="s1">&apos;attribute vec3 position;\</span>
<span class="s1">    varying vec2 uv;\</span>
<span class="s1">    void main() {\</span>
<span class="s1">      gl_Position = vec4(position, 1.0);\</span>
<span class="s1">      uv = position.xy;\</span>
<span class="s1">    }&apos;</span><span class="p">,</span>
    <span class="s1">&apos;precision highp float;\</span>
<span class="s1">    uniform float t;\</span>
<span class="s1">    varying vec2 uv;\</span>
<span class="s1">    void main() {\</span>
<span class="s1">      gl_FragColor = vec4(0.5*(uv+1.0), 0.5*(cos(t)+1.0), 1.0);\</span>
<span class="s1">    }&apos;</span><span class="p">)</span>

  <span class="c1">//Create vertex buffer</span>
  <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">()</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">)</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
  <span class="p">]),</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">shell</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&apos;gl-render&apos;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">gl</span>

  <span class="c1">//Bind shader</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">bind</span><span class="p">()</span>

  <span class="c1">//Set attributes</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">)</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">pointer</span><span class="p">()</span>

  <span class="c1">//Set uniforms</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">t</span> <span class="o">+=</span> <span class="mf">0.01</span>

  <span class="c1">//Draw</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>Here is the result:</p>
<p><img src="https://raw.github.com/stackgl/gl-shader/master/screenshot.png"></p>
<h1 id="install">Install</h1>
<pre><code>npm install gl-shader
</code></pre><h1 id="api">API</h1>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">createShader</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;gl-shader&apos;</span><span class="p">)</span>
</code></pre>
<h3 id="constructor">Constructor</h3>
<p>There are two main usages for the constructor.  First,</p>
<h4 id="-var-shader-createshader-vertexsource-fragmentsource-uniforms-attributes-"><code>var shader = createShader(vertexSource, fragmentSource[, uniforms, attributes])</code></h4>
<p>Constructs a wrapped shader object with shims for all of the uniforms and attributes in the program.</p>
<ul>
<li><code>gl</code> is the webgl context in which the program will be created</li>
<li><code>vertexSource</code> is the source code for the vertex shader</li>
<li><code>fragmentSource</code> is the source code for the fragment shader</li>
<li><code>uniforms</code> is an (optional) list of all uniforms exported by the shader program</li>
<li><code>attributes</code> is an (optional) list of all attributes exported by the shader program</li>
</ul>
<p>The format of <code>uniforms</code> and <code>attributes</code> is consistent with <code>glslify</code>&apos;s output</p>
<p><strong>Returns</strong> A compiled shader object.</p>
<p>You can specify a default <code>location</code> number for each attribute, otherwise WebGL will bind it automatically. </p>
<h4 id="-var-shader-createshader-gl-glslifyresult-"><code>var shader = createShader(gl, glslifyResult)</code></h4>
<p>Constructs a shader object from the output of <code>glslify</code>.</p>
<ul>
<li><code>gl</code> is a WebGL context</li>
<li><code>glslify</code> is the output of <code>glslify</code></li>
</ul>
<p><strong>Returns</strong> A wrapped shader object</p>
<h3 id="methods">Methods</h3>
<h4 id="-shader-bind-"><code>shader.bind()</code></h4>
<p>Binds the shader for rendering</p>
<h4 id="-shader-update-vertsource-fragsource-uniforms-attributes-"><code>shader.update(vertSource,fragSource[,uniforms,attributes])</code></h4>
<p>Rebuilds the shader object with new vertex and fragment shaders (same behavior as constructor)</p>
<h4 id="-shader-update-glslifyresult-"><code>shader.update(glslifyResult)</code></h4>
<p>Rebuilds the shader object with new vertex and fragment shaders (same behavior as constructor)</p>
<h4 id="-shader-dispose-"><code>shader.dispose()</code></h4>
<p>Deletes the shader program and associated resources.</p>
<h3 id="properties">Properties</h3>
<h4 id="-gl-"><code>gl</code></h4>
<p>The WebGL context associated to the shader</p>
<h4 id="-program-"><code>program</code></h4>
<p>A reference to the underlying program object in the WebGL context</p>
<h4 id="-vertshader-"><code>vertShader</code></h4>
<p>A reference to the underlying vertex shader object</p>
<h4 id="-fragshader-"><code>fragShader</code></h4>
<p>A reference to the underlying fragment shader object</p>
<h3 id="uniforms">Uniforms</h3>
<p>The uniforms for the shader program are packaged up as properties in the <code>shader.uniforms</code> object.  The shader must be bound before the uniforms are assigned. For example, to update a scalar uniform you can just assign to it:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">bind</span><span class="p">()</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span> <span class="o">=</span> <span class="mf">1.0</span>
</code></pre>
<p>While you can update vector uniforms by writing an array to them:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</code></pre>
<p>Matrix uniforms must have their arrays flattened first:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">]</span>
</code></pre>
<p>You can read the value of uniform too if the underlying shader is currently bound.  For example,</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">bind</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span><span class="p">)</span>
</code></pre>
<p>Struct uniforms can also be accessed using the normal dot property syntax:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">light</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<p>It is also possible to initialize uniforms in bulk by assigning an object:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">model</span><span class="o">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="nx">color</span><span class="o">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>The contents of uniform values are lost when a shader is unbound.</p>
<h3 id="attributes">Attributes</h3>
<p>The basic idea behind the attribute interface is similar to that for uniforms, however because attributes can be either a constant value or get values from a vertex array they have a slightly more complicated interface.  All of the attributes are stored in the <code>shader.attributes</code> property.</p>
<h4 id="-attrib-constant-"><code>attrib = constant</code></h4>
<p>For non-array attributes you can set the constant value to be broadcast across all vertices.  For example, to set the vertex color of a shader to a constant you could do:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<p>This internally uses <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttrib.xml"><code>gl.vertexAttribnf</code></a>. Setting the attribute will also call <code>gl.disableVertexAttribArray</code> on the attribute&apos;s location.</p>
<h4 id="-attrib-location-"><code>attrib.location</code></h4>
<p>This property accesses the location of the attribute.  You can assign/read from it to modify the location of the attribute.  For example, you can update the location by doing:</p>
<pre><code class="lang-javascript"><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<p>Or you can read the currently bound location back by just accessing it:</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span><span class="p">)</span>
</code></pre>
<p><strong>WARNING</strong> Changing the attribute location requires recompiling the program. This recompilation is deferred until the next call to <code>.bind()</code></p>
<h4 id="-attrib-pointer-type-normalized-stride-offset-"><code>attrib.pointer([type, normalized, stride, offset])</code></h4>
<p>A shortcut for <code>gl.vertexAttribPointer</code>/<code>gl.enableVertexAttribArray</code>.  See the <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml">OpenGL man page for details on how this works</a>.  The main difference here is that the WebGL context, size and index are known and so these parameters are bound.</p>
<ul>
<li><code>type</code> is the type of the pointer (default <code>gl.FLOAT</code>)</li>
<li><code>normalized</code> specifies whether fixed-point data values should be normalized (<code>true</code>) or converted directly as fixed-point values (<code>false</code>) when they are accessed.  (Default <code>false</code>)</li>
<li><code>stride</code> the byte offset between consecutive generic vertex attributes.  (Default: <code>0</code>)</li>
<li><code>offset</code> offset of the first element of the array in bytes. (Default <code>0</code>)</li>
</ul>
<h4 id="matrix-attributes">Matrix attributes</h4>
<p>Matrix attributes are also supported, however there are a few subtle difference.  Due to WebGL limitations, d-dimensional matrix attributes require d separate attribute locations.  If <code>matrix</code> is a matrix attribute, then the rows of the matrix can be accessed independently using:</p>
<pre><code class="lang-javascript"><span class="c1">//First row of matrix</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">//Second row</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">// ... etc.</span>
</code></pre>
<p>The interface for these attributes is identical to the above interfaces for vector attributes (support constant setters, <code>.pointer()</code>, and <code>.location</code>).</p>
<p>There is also a bulk interface which simplifies working with the matrix as a whole unit.  For example, it is possible to update the location of each row of the matrix simultaneously by assigning it a vector value:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre>
<p>Similarly, if the matrix attribute is stored as a contiguous range in memory, the pointer for each row can be set using <code>.pointer()</code>.  For example, if <code>matrix</code> is a 4x4 matrix attribute then,</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">.</span><span class="nx">pointer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
<p>is equivalent to,</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">pointer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">pointer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">pointer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">pointer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
</code></pre>
<h3 id="reflection">Reflection</h3>
<p>Finally, the library supports some reflection capabilities.  The set of all uniforms and data types are stored in the &quot;type&quot; property of the shader object,</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">types</span><span class="p">)</span>
</code></pre>
<p>This reflects the uniform and attribute parameters that were passed to the shader constructor.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>(c) 2013-2015 Mikola Lysenko.  MIT License</p>
