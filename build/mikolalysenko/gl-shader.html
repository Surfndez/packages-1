<h1 id="gl-shader">gl-shader</h1>
<p>Simple wrapper for WebGL shaders</p>
<iframe scrolling="no" seamless="seamless" src="http://mikolalysenko.github.io/gl-shader/"></iframe><h1 id="example">Example</h1>
<p>Try it out now in your browser:  <a href="http://mikolalysenko.github.io/gl-shader/">http://mikolalysenko.github.io/gl-shader/</a></p>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">shell</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;gl-now&quot;</span><span class="p">)()</span>
<span class="kd">var</span> <span class="nx">createShader</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;gl-shader&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">shader</span><span class="p">,</span> <span class="nx">buffer</span>

<span class="nx">shell</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;gl-init&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">gl</span>

  <span class="c1">//Create shader</span>
  <span class="nx">shader</span> <span class="o">=</span> <span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">,</span>
    <span class="s2">&quot;attribute vec3 position;\</span>
<span class="s2">    varying vec2 uv;\</span>
<span class="s2">    void main() {\</span>
<span class="s2">      gl_Position = vec4(position, 1.0);\</span>
<span class="s2">      uv = position.xy;\</span>
<span class="s2">    }&quot;</span><span class="p">,</span>
    <span class="s2">&quot;precision highp float;\</span>
<span class="s2">    uniform float t;\</span>
<span class="s2">    varying vec2 uv;\</span>
<span class="s2">    void main() {\</span>
<span class="s2">      gl_FragColor = vec4(0.5*(uv+1.0), 0.5*(cos(t)+1.0), 1.0);\</span>
<span class="s2">    }&quot;</span><span class="p">)</span>

  <span class="c1">//Create vertex buffer</span>
  <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">()</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">)</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
  <span class="p">]),</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">shell</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;gl-render&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">gl</span>

  <span class="c1">//Bind shader</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">bind</span><span class="p">()</span>

  <span class="c1">//Set attributes</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">)</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">pointer</span><span class="p">()</span>

  <span class="c1">//Set uniforms</span>
  <span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">t</span> <span class="o">+=</span> <span class="mf">0.01</span>

  <span class="c1">//Draw</span>
  <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>Here is the result:</p>
<p><img src="https://raw.github.com/mikolalysenko/gl-shader/master/screenshot.png"></p>
<h1 id="install">Install</h1>
<pre><code>npm install gl-shader
</code></pre><h1 id="api">API</h1>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">createShader</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;gl-shader&quot;</span><span class="p">)</span>
</code></pre>
<h3 id="-var-shader-createshader-gl-vert_src-frag_src-"><code>var shader = createShader(gl, vert_src, frag_src)</code></h3>
<p>Creates a shader in the WebGL context with the given vertex and fragment shader sources.</p>
<ul>
<li><code>gl</code> is the WebGL context to create the shader in</li>
<li><code>vert_src</code> is the vertex shader source</li>
<li><code>frag_src</code> is the fragment shader source</li>
</ul>
<p><strong>Returns</strong> A <code>GLShader</code> object which wraps a WebGL program</p>
<p><strong>Throws</strong> If there are any errors when creating the shader.</p>
<h3 id="-shader-gl-"><code>shader.gl</code></h3>
<p>A reference to the WebGL context of the shader.</p>
<h3 id="-shader-handle-"><code>shader.handle</code></h3>
<p>A handle to the underlying WebGLProgram object that the shader wraps.</p>
<h3 id="-shader-fragmentshader-"><code>shader.fragmentShader</code></h3>
<p>A handle to the underlying fragment shader object.</p>
<h3 id="-shader-vertexshader-"><code>shader.vertexShader</code></h3>
<p>A handle to the underlying vertex shader object.</p>
<h3 id="-shader-bind-"><code>shader.bind()</code></h3>
<p>Binds the shader to the currently used program.  Essentially a shorthand for:</p>
<pre><code class="lang-javascript"><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">program</span><span class="p">)</span>
</code></pre>
<h3 id="-shader-dispose-"><code>shader.dispose()</code></h3>
<p>Release all resources associated with the shader</p>
<h2 id="uniforms">Uniforms</h2>
<p>The uniforms for the shader program are packaged up as properties in the <code>shader.uniforms</code> object.  For example, to update a scalar uniform you can just assign to it:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span> <span class="o">=</span> <span class="mf">1.0</span>
</code></pre>
<p>While you can update vector uniforms by writing an array to them:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</code></pre>
<p>Matrix uniforms must have their arrays flattened first:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">]</span>
</code></pre>
<p>You can also read the value of uniform too if the underlying shader is currently bound.  For example,</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">scalar</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">vector</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">matrix</span><span class="p">)</span>
</code></pre>
<p>Struct uniforms can also be accessed using the normal dot property syntax.  For example,</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span><span class="p">.</span><span class="nx">light</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<p>You can also assign to structs or even entire collections of uniforms by writing to them with an object:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">uniforms</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">color</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="nx">intensity</span><span class="o">:</span> <span class="mf">100.0</span><span class="p">,</span>
  <span class="nx">light</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">position</span><span class="o">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="nx">direction</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id="attributes">Attributes</h2>
<p>The basic idea behind the attribute interface is similar to that for uniforms, however because attributes can be either a constant value or get values from a vertex array the situation is slightly more complicated.  All of the attributes are stored in the <code>shader.attributes</code> property.</p>
<h3 id="-attrib-value-"><code>attrib = value</code></h3>
<p>For non-array attributes you can set the constant value to be broadcast across all vertices.  For example, to set the vertex color of a shader to a constant you could do:</p>
<pre><code class="lang-javascript"><span class="nx">shader</span><span class="p">.</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre>
<p>This internally uses <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttrib.xml"><code>gl.vertexAttribnf</code></a>.</p>
<h3 id="-attrib-location-"><code>attrib.location</code></h3>
<p>This property accesses the location of the attribute.  You can assign/read from it to modify the location of the attribute.  For example, you can update the location by doing:</p>
<pre><code class="lang-javascript"><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<p>Or you can read the currently bound location back by just accessing it:</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">attrib</span><span class="p">.</span><span class="nx">location</span><span class="p">)</span>
</code></pre>
<p>Internally, these methods just call <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindAttribLocation.xml"><code>gl.bindAttribLocation</code></a> and access the stored location.</p>
<p><strong>WARNING</strong> Changing the attribute location requires recompiling the program.  Do not dynamically modify this variable in your render loop.</p>
<h3 id="-attrib-pointer-type-normalized-stride-offset-"><code>attrib.pointer([type, normalized, stride, offset])</code></h3>
<p>A shortcut for <code>gl.vertexAttribPointer</code>.  See the <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml">OpenGL man page for details on how this works</a>.  The main difference here is that the WebGL context, size and index are known and so these parameters are bound.</p>
<ul>
<li><code>type</code> is the type of the pointer (default <code>gl.FLOAT</code>)</li>
<li><code>normalized</code> specifies whether fixed-point data values should be normalized (<code>true</code>) or converted directly as fixed-point values (<code>false</code>) when they are accessed.  (Default <code>false</code>)</li>
<li><code>stride</code> the byte offset between consecutive generic vertex attributes.  (Default: <code>0</code>)</li>
<li><code>offset</code> offset of the first element of the array in bytes. (Default <code>0</code>)</li>
</ul>
<h2 id="reflection">Reflection</h2>
<p>Finally, the library supports some reflection capabilities.  The set of all uniforms and data types are stored in the &quot;type&quot; property of the shader object,</p>
<pre><code class="lang-javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shader</span><span class="p">.</span><span class="nx">types</span><span class="p">)</span>
</code></pre>
<h2 id="credits">Credits</h2>
<p>(c) 2013 Mikola Lysenko. MIT License</p>
