<h1 id="gl-shader-output"><a target="_blank" href="http://github.com/Jam3/gl-shader-output">gl-shader-output</a></h1>
<p><a href="http://github.com/badges/stability-badges"></a></p>
<p><img src="http://i.imgur.com/bROGMVq.png" alt="img"></p>
<p>A helper module for unit testing shaders and comparing the result of <code>gl_FragColor</code> from a 1x1 WebGL canvas. See <a href="https://github.com/Jam3/glsl-hsl2rgb">glsl-hsl2rgb</a> for a practical example. </p>
<p>Example: </p>
<pre><code class="lang-js"><span class="kd">var</span> <span class="nx">ShaderOutput</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;gl-shader-output&apos;</span><span class="p">)</span>

<span class="c1">//your shader, could be a simple glsl-shader-core object</span>
<span class="kd">var</span> <span class="nx">glslify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;glslify&apos;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">shader</span> <span class="o">=</span> <span class="nx">glslify</span><span class="p">({</span>
    <span class="nx">vertex</span><span class="o">:</span> <span class="p">[</span>
        <span class="s1">&apos;attribute vec2 position;&apos;</span><span class="p">,</span>
        <span class="s1">&apos;void main() {&apos;</span><span class="p">,</span>
          <span class="s1">&apos;gl_Position = vec4(position, 1.0, 1.0);&apos;</span><span class="p">,</span>
        <span class="s1">&apos;}&apos;</span>
    <span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&apos;\n&apos;</span><span class="p">)</span>
    <span class="nx">fragment</span><span class="o">:</span> <span class="p">[</span>
        <span class="s1">&apos;precision mediump float;&apos;</span><span class="p">,</span>
        <span class="s1">&apos;uniform float green;&apos;</span><span class="p">,</span>
        <span class="s1">&apos;void main() {&apos;</span><span class="p">,</span>
            <span class="s1">&apos;gl_FragColor = vec4(0.0, green, 0.0, 1.0);&apos;</span><span class="p">,</span>
        <span class="s1">&apos;}&apos;</span>
    <span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&apos;\n&apos;</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">//get a draw function for our test</span>
<span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="nx">ShaderOutput</span><span class="p">({</span>
    <span class="nx">shader</span><span class="o">:</span> <span class="nx">shader</span>
<span class="p">})</span>

<span class="c1">//returns the frag color as [R, G, B, A]</span>
<span class="kd">var</span> <span class="nx">color</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">()</span>

<span class="c1">//we could also set uniforms before rendering</span>
<span class="kd">var</span> <span class="nx">color2</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">({</span> <span class="nx">green</span><span class="o">:</span> <span class="mf">0.5</span> <span class="p">})</span>

<span class="c1">//due to precision loss, you may want to use a fuzzy equality check</span>
<span class="kd">var</span> <span class="nx">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="kd">var</span> <span class="nx">almostEqual</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&apos;array-almost-equal&apos;</span><span class="p">)</span>
<span class="nx">almostEqual</span><span class="p">(</span><span class="nx">color2</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nx">epsilon</span><span class="p">)</span>
</code></pre>
<p>You can use this with tools like <a href="https://github.com/hughsk/smokestack">smokestack</a> for test-driven GLSL development. </p>
<h2 id="usage">Usage</h2>
<p><a href="https://www.npmjs.com/package/gl-shader-output"></a></p>
<h4 id="-draw-shaderoutput-opt-"><code>draw = ShaderOutput(opt)</code></h4>
<p>Takes the following options, and returns a <code>draw</code> function.</p>
<ul>
<li><code>shader</code> the shader (required), can be a function that accepts <code>gl</code> or an instance of gl-shader </li>
<li><code>gl</code> the gl state to re-use, expected to hold a 1x1 canvas (creates a new one if not specified)</li>
<li><a href="https://www.npmjs.com/package/webgl-context">webgl-context</a> options such as <code>alpha</code> and <code>premultipliedAlpha</code></li>
</ul>
<p>The draw function has the following signature:</p>
<pre><code class="lang-js"><span class="kd">var</span> <span class="nx">fragColor</span> <span class="o">=</span> <span class="nx">draw</span><span class="p">([</span><span class="nx">uniforms</span><span class="p">])</span>
</code></pre>
<p>Where <code>uniforms</code> is an optional map of uniform names to values (such as <code>[x, y]</code> array for vec2), applied before rendering.</p>
<p>The return value is the gl_FragColor RGBA of the canvas, in floats, such as <code>[0.5, 1.0, 0.25, 1.0]</code>.</p>
<h2 id="license">License</h2>
<p>MIT, see <a href="http://github.com/Jam3/gl-shader-output/blob/master/LICENSE.md">LICENSE.md</a> for details.</p>
